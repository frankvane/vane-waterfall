å¥½çš„ï¼æˆ‘æ¥ä¸ºä½ è®¾è®¡ä¸€ä¸ªå®Œæ•´ã€å…¨é¢çš„ WaterfallPlugin ç³»ç»Ÿï¼Œä¿æŒä¸ LazyLoadImagePlugin ä¸€è‡´çš„ä»£ç ç»“æ„å’Œæ ‡å‡†ã€‚

## ğŸ“ ç¬¬ä¸€æ­¥ï¼šç›®å½•ç»“æ„è§„åˆ’

```
src/components/WaterfallPlugin/
â”œâ”€â”€ core/
â”‚   â””â”€â”€ WaterfallCore.tsx           # æ ¸å¿ƒç€‘å¸ƒæµç»„ä»¶
â”œâ”€â”€ plugins/
â”‚   â”œâ”€â”€ types.ts                     # æ’ä»¶ç±»å‹å®šä¹‰ï¼ˆæ ¸å¿ƒï¼‰
â”‚   â”œâ”€â”€ PluginBus.ts                 # äº‹ä»¶æ€»çº¿
â”‚   â”œâ”€â”€ PluginManager.ts             # æ’ä»¶ç®¡ç†å™¨
â”‚   â”œâ”€â”€ withPlugins.tsx              # HOC ç»„åˆå™¨
â”‚   â””â”€â”€ index.ts                     # æ’ä»¶ç³»ç»Ÿå¯¼å‡º
â”œâ”€â”€ custom-plugins/
â”‚   â”œâ”€â”€ ResponsiveColumnsPlugin/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”œâ”€â”€ VirtualScrollPlugin/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”œâ”€â”€ InfiniteScrollPlugin/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”œâ”€â”€ AnimationPlugin/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”œâ”€â”€ LazyLoadPlugin/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”œâ”€â”€ FilterPlugin/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”œâ”€â”€ SortPlugin/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”œâ”€â”€ SelectionPlugin/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â””â”€â”€ index.ts                     # ç»Ÿä¸€å¯¼å‡ºæ‰€æœ‰æ’ä»¶
â””â”€â”€ index.ts                         # ä¸»å…¥å£
```

## ğŸ“ ç¬¬äºŒæ­¥ï¼šæ ¸å¿ƒç±»å‹å®šä¹‰ `plugins/types.ts`

```typescript
/**
 * WaterfallPlugin æ’ä»¶ç³»ç»Ÿç±»å‹å®šä¹‰
 * å‚è€ƒ LazyLoadImagePlugin æ¶æ„è®¾è®¡
 */

import type React from "react";
import type { WaterfallCoreProps } from "../core/WaterfallCore";

// ============ åŸºç¡€æ•°æ®ç±»å‹ ============

/**
 * ç€‘å¸ƒæµé¡¹çš„ä½ç½®ä¿¡æ¯
 */
export interface ItemPosition {
  x: number;
  y: number;
  width: number;
  height: number;
  column: number; // æ‰€å±åˆ—
  row: number; // æ‰€å±è¡Œï¼ˆè™šæ‹Ÿè¡Œæ¦‚å¿µï¼‰
}

/**
 * å¸ƒå±€ä¿¡æ¯
 */
export interface LayoutInfo {
  columns: number; // å½“å‰åˆ—æ•°
  columnWidth: number; // åˆ—å®½
  gap: number; // é—´è·
  columnHeights: number[]; // æ¯åˆ—çš„é«˜åº¦
  totalHeight: number; // æ€»é«˜åº¦
  containerWidth: number; // å®¹å™¨å®½åº¦
  containerHeight: number; // å®¹å™¨é«˜åº¦
}

/**
 * è§†å£ä¿¡æ¯
 */
export interface ViewportInfo {
  scrollTop: number;
  scrollLeft: number;
  scrollHeight: number;
  scrollWidth: number;
  clientHeight: number;
  clientWidth: number;
  isScrolling: boolean;
  direction: "up" | "down" | "left" | "right" | null;
}

/**
 * é¡¹å¯è§æ€§ä¿¡æ¯
 */
export interface ItemVisibility {
  index: number;
  isVisible: boolean;
  visibleRatio: number; // 0-1
  isAboveViewport: boolean;
  isBelowViewport: boolean;
}

/**
 * æ€§èƒ½æŒ‡æ ‡
 */
export interface PerformanceMetrics {
  // å¸ƒå±€ç›¸å…³
  layoutStartTime: number;
  layoutEndTime?: number;
  layoutDuration?: number;
  layoutCount: number;

  // æ¸²æŸ“ç›¸å…³
  renderStartTime?: number;
  renderEndTime?: number;
  renderDuration?: number;
  renderedItemCount: number;

  // æ»šåŠ¨ç›¸å…³
  scrollStartTime?: number;
  scrollEndTime?: number;
  scrollDuration?: number;
  scrollDistance?: number;

  // å†…å­˜ç›¸å…³
  itemCount: number;
  visibleItemCount: number;
  memoryUsage?: number;
}

/**
 * è®¾å¤‡ä¿¡æ¯
 */
export interface DeviceInfo {
  type: "mobile" | "tablet" | "desktop";
  os: string;
  browser: string;
  devicePixelRatio: number;
  viewportWidth: number;
  viewportHeight: number;
  isTouchDevice: boolean;
  isRetina: boolean;
}

/**
 * ç½‘ç»œä¿¡æ¯
 */
export interface NetworkInfo {
  effectiveType: "4g" | "3g" | "2g" | "slow-2g";
  downlink: number; // Mbps
  rtt: number; // ms
  saveData: boolean;
  online: boolean;
}

/**
 * åŠ¨ç”»é…ç½®
 */
export interface AnimationConfig {
  duration: number;
  delay?: number;
  easing?: string;
  stagger?: number; // äº¤é”™å»¶è¿Ÿ
}

/**
 * æ‹–æ‹½ä¿¡æ¯
 */
export interface DragInfo {
  isDragging: boolean;
  draggedIndex: number | null;
  dragStartX: number;
  dragStartY: number;
  dragCurrentX: number;
  dragCurrentY: number;
  dropTargetIndex: number | null;
}

// ============ æ’ä»¶é€šä¿¡æ€»çº¿ ============

export interface PluginBus {
  // äº‹ä»¶å‘å¸ƒè®¢é˜…
  emit: <T = any>(event: string, data?: T) => void;
  on: <T = any>(event: string, handler: (data: T) => void) => () => void;
  once: <T = any>(event: string, handler: (data: T) => void) => () => void;
  off: (event: string, handler?: Function) => void;

  // æ•°æ®å…±äº«
  getData: <T = any>(key: string) => T | undefined;
  setData: <T = any>(key: string, value: T) => void;
  deleteData: (key: string) => void;
  hasData: (key: string) => boolean;

  // æ‰¹é‡æ“ä½œ
  getAll: () => Record<string, any>;
  clear: () => void;
}

// ============ æ’ä»¶ä¸Šä¸‹æ–‡ ============

export interface WaterfallPluginContext<T = any> {
  // åŸºç¡€æ•°æ®
  items: T[];
  itemCount: number;

  // DOM å¼•ç”¨
  containerRef: React.RefObject<HTMLDivElement | null>;
  itemRefs: Map<number, HTMLElement>;
  getItemRef: (index: number) => HTMLElement | null;

  // å¸ƒå±€ä¿¡æ¯
  layout: LayoutInfo;
  itemPositions: Map<number, ItemPosition>;
  getItemPosition: (index: number) => ItemPosition | null;

  // è§†å£ä¿¡æ¯
  viewport: ViewportInfo;
  visibleItems: Set<number>; // å½“å‰å¯è§çš„é¡¹ç´¢å¼•é›†åˆ
  visibleRange: { start: number; end: number }; // å¯è§èŒƒå›´

  // çŠ¶æ€
  isLayouting: boolean;
  isScrolling: boolean;
  isDragging: boolean;
  isLoading: boolean;
  hasMore: boolean;
  error: Error | null;

  // é…ç½®
  props: WaterfallCoreProps<T>;

  // æ’ä»¶é€šä¿¡
  bus?: PluginBus;
  sharedData?: Map<string, any>;

  // æ‰©å±•ä¿¡æ¯
  deviceInfo?: DeviceInfo;
  networkInfo?: NetworkInfo;
  performanceMetrics?: PerformanceMetrics;
  dragInfo?: DragInfo;

  // å·¥å…·æ–¹æ³•
  relayout: () => void;
  scrollToItem: (index: number, options?: ScrollToOptions) => void;
  scrollToTop: (options?: ScrollToOptions) => void;
  scrollToBottom: (options?: ScrollToOptions) => void;
  measureItem: (index: number) => Promise<{ width: number; height: number }>;
  forceUpdate: () => void;
}

export interface ScrollToOptions {
  behavior?: "auto" | "smooth";
  block?: "start" | "center" | "end" | "nearest";
  inline?: "start" | "center" | "end" | "nearest";
}

// ============ æ’ä»¶é’©å­å®šä¹‰ ============

export interface WaterfallPluginHooks<T = any> {
  // ========== ç”Ÿå‘½å‘¨æœŸé’©å­ ==========

  /**
   * ç»„ä»¶æŒ‚è½½æ—¶è§¦å‘
   * @returns æ¸…ç†å‡½æ•°ï¼ˆå¯é€‰ï¼‰
   */
  onMount?: (context: WaterfallPluginContext<T>) => void | (() => void);

  /**
   * ç»„ä»¶å¸è½½æ—¶è§¦å‘
   */
  onUnmount?: (context: WaterfallPluginContext<T>) => void;

  /**
   * Props å˜åŒ–æ—¶è§¦å‘
   */
  onPropsChange?: (
    context: WaterfallPluginContext<T>,
    prevProps: WaterfallCoreProps<T>,
    nextProps: WaterfallCoreProps<T>
  ) => void;

  // ========== å¸ƒå±€é’©å­ ==========

  /**
   * å¸ƒå±€å¼€å§‹å‰è§¦å‘
   * @returns false å¯ä»¥é˜»æ­¢å¸ƒå±€
   */
  onBeforeLayout?: (
    context: WaterfallPluginContext<T>
  ) => boolean | Promise<boolean>;

  /**
   * å¸ƒå±€è®¡ç®—ä¸­è§¦å‘ï¼ˆå¯ä»¥ä¿®æ”¹å¸ƒå±€é€»è¾‘ï¼‰
   */
  onLayout?: (context: WaterfallPluginContext<T>) => void;

  /**
   * å¸ƒå±€å®Œæˆåè§¦å‘
   */
  onLayoutComplete?: (context: WaterfallPluginContext<T>) => void;

  /**
   * è®¡ç®—åˆ—æ•°ï¼ˆå“åº”å¼æ’ä»¶ä¼šå®ç°æ­¤é’©å­ï¼‰
   * @returns åˆ—æ•°ï¼Œundefined è¡¨ç¤ºä½¿ç”¨é»˜è®¤å€¼
   */
  calculateColumns?: (context: WaterfallPluginContext<T>) => number | undefined;

  /**
   * è®¡ç®—åˆ—å®½ï¼ˆè‡ªå®šä¹‰åˆ—å®½æ’ä»¶ä¼šå®ç°ï¼‰
   */
  calculateColumnWidth?: (
    context: WaterfallPluginContext<T>,
    containerWidth: number,
    columns: number
  ) => number | undefined;

  /**
   * è®¡ç®—é¡¹ä½ç½®ï¼ˆè‡ªå®šä¹‰å¸ƒå±€ç®—æ³•æ’ä»¶ä¼šå®ç°ï¼‰
   */
  calculateItemPosition?: (
    context: WaterfallPluginContext<T>,
    index: number,
    itemHeight: number
  ) => ItemPosition | undefined;

  // ========== é¡¹ç”Ÿå‘½å‘¨æœŸé’©å­ ==========

  /**
   * é¡¹æŒ‚è½½æ—¶è§¦å‘
   */
  onItemMount?: (
    context: WaterfallPluginContext<T>,
    index: number,
    element: HTMLElement
  ) => void;

  /**
   * é¡¹å¸è½½æ—¶è§¦å‘
   */
  onItemUnmount?: (context: WaterfallPluginContext<T>, index: number) => void;

  /**
   * é¡¹è¿›å…¥è§†å£æ—¶è§¦å‘
   */
  onItemEnterViewport?: (
    context: WaterfallPluginContext<T>,
    index: number,
    visibility: ItemVisibility
  ) => void;

  /**
   * é¡¹ç¦»å¼€è§†å£æ—¶è§¦å‘
   */
  onItemLeaveViewport?: (
    context: WaterfallPluginContext<T>,
    index: number,
    visibility: ItemVisibility
  ) => void;

  /**
   * é¡¹å¯è§æ€§å˜åŒ–æ—¶è§¦å‘
   */
  onItemVisibilityChange?: (
    context: WaterfallPluginContext<T>,
    index: number,
    visibility: ItemVisibility
  ) => void;

  /**
   * é¡¹ç‚¹å‡»æ—¶è§¦å‘
   */
  onItemClick?: (
    context: WaterfallPluginContext<T>,
    index: number,
    item: T,
    event: React.MouseEvent
  ) => void;

  // ========== æ»šåŠ¨é’©å­ ==========

  /**
   * æ»šåŠ¨å¼€å§‹æ—¶è§¦å‘
   */
  onScrollStart?: (context: WaterfallPluginContext<T>) => void;

  /**
   * æ»šåŠ¨ä¸­è§¦å‘
   */
  onScroll?: (
    context: WaterfallPluginContext<T>,
    scrollTop: number,
    scrollLeft: number
  ) => void;

  /**
   * æ»šåŠ¨ç»“æŸæ—¶è§¦å‘
   */
  onScrollEnd?: (context: WaterfallPluginContext<T>) => void;

  /**
   * æ»šåŠ¨åˆ°åº•éƒ¨æ—¶è§¦å‘ï¼ˆç”¨äºæ— é™æ»šåŠ¨ï¼‰
   */
  onReachBottom?: (
    context: WaterfallPluginContext<T>,
    distance: number
  ) => void | Promise<void>;

  /**
   * æ»šåŠ¨åˆ°é¡¶éƒ¨æ—¶è§¦å‘
   */
  onReachTop?: (context: WaterfallPluginContext<T>) => void;

  // ========== å°ºå¯¸å˜åŒ–é’©å­ ==========

  /**
   * å®¹å™¨å°ºå¯¸å˜åŒ–æ—¶è§¦å‘
   */
  onResize?: (
    context: WaterfallPluginContext<T>,
    width: number,
    height: number
  ) => void;

  /**
   * é¡¹å°ºå¯¸å˜åŒ–æ—¶è§¦å‘
   */
  onItemResize?: (
    context: WaterfallPluginContext<T>,
    index: number,
    width: number,
    height: number
  ) => void;

  // ========== æ•°æ®é’©å­ ==========

  /**
   * æ•°æ®å˜åŒ–å‰è§¦å‘
   * @returns false å¯ä»¥é˜»æ­¢æ•°æ®æ›´æ–°
   */
  onBeforeItemsChange?: (
    context: WaterfallPluginContext<T>,
    oldItems: T[],
    newItems: T[]
  ) => boolean | Promise<boolean>;

  /**
   * æ•°æ®å˜åŒ–åè§¦å‘
   */
  onItemsChange?: (
    context: WaterfallPluginContext<T>,
    oldItems: T[],
    newItems: T[]
  ) => void;

  /**
   * å•ä¸ªé¡¹æ•°æ®å˜åŒ–æ—¶è§¦å‘
   */
  onItemChange?: (
    context: WaterfallPluginContext<T>,
    index: number,
    oldItem: T,
    newItem: T
  ) => void;

  /**
   * åŠ è½½æ›´å¤šæ•°æ®æ—¶è§¦å‘ï¼ˆæ— é™æ»šåŠ¨æ’ä»¶ä¼šå®ç°ï¼‰
   */
  onLoadMore?: (
    context: WaterfallPluginContext<T>,
    page: number
  ) => Promise<T[]> | T[] | void;

  /**
   * åˆ·æ–°æ•°æ®æ—¶è§¦å‘ï¼ˆä¸‹æ‹‰åˆ·æ–°æ’ä»¶ä¼šå®ç°ï¼‰
   */
  onRefresh?: (context: WaterfallPluginContext<T>) => Promise<T[]> | T[] | void;

  // ========== äº¤äº’é’©å­ ==========

  /**
   * æ‹–æ‹½å¼€å§‹æ—¶è§¦å‘
   */
  onDragStart?: (
    context: WaterfallPluginContext<T>,
    index: number,
    event: React.DragEvent
  ) => void;

  /**
   * æ‹–æ‹½ä¸­è§¦å‘
   */
  onDrag?: (
    context: WaterfallPluginContext<T>,
    index: number,
    event: React.DragEvent
  ) => void;

  /**
   * æ‹–æ‹½ç»“æŸæ—¶è§¦å‘
   */
  onDragEnd?: (
    context: WaterfallPluginContext<T>,
    index: number,
    event: React.DragEvent
  ) => void;

  /**
   * é¡¹è¢«æ‹–æ”¾æ—¶è§¦å‘
   */
  onDrop?: (
    context: WaterfallPluginContext<T>,
    fromIndex: number,
    toIndex: number
  ) => void;

  /**
   * é¡¹è¢«é€‰ä¸­æ—¶è§¦å‘
   */
  onItemSelect?: (
    context: WaterfallPluginContext<T>,
    index: number,
    item: T,
    selected: boolean
  ) => void;

  /**
   * å¤šé€‰å˜åŒ–æ—¶è§¦å‘
   */
  onSelectionChange?: (
    context: WaterfallPluginContext<T>,
    selectedIndices: Set<number>
  ) => void;

  // ========== ç­›é€‰ä¸æ’åºé’©å­ ==========

  /**
   * ç­›é€‰é€»è¾‘ï¼ˆç­›é€‰æ’ä»¶ä¼šå®ç°ï¼‰
   */
  filterItem?: (
    context: WaterfallPluginContext<T>,
    item: T,
    index: number
  ) => boolean;

  /**
   * æ’åºé€»è¾‘ï¼ˆæ’åºæ’ä»¶ä¼šå®ç°ï¼‰
   */
  sortItems?: (context: WaterfallPluginContext<T>, items: T[]) => T[];

  /**
   * æœç´¢é€»è¾‘ï¼ˆæœç´¢æ’ä»¶ä¼šå®ç°ï¼‰
   */
  searchItem?: (
    context: WaterfallPluginContext<T>,
    item: T,
    query: string
  ) => boolean;

  // ========== æ€§èƒ½é’©å­ ==========

  /**
   * æ€§èƒ½æŒ‡æ ‡æ”¶é›†
   */
  onPerformanceMetric?: (
    context: WaterfallPluginContext<T>,
    metrics: PerformanceMetrics
  ) => void;

  /**
   * è™šæ‹Ÿæ»šåŠ¨èŒƒå›´è®¡ç®—ï¼ˆè™šæ‹Ÿæ»šåŠ¨æ’ä»¶ä¼šå®ç°ï¼‰
   */
  calculateVisibleRange?: (
    context: WaterfallPluginContext<T>
  ) => { start: number; end: number } | undefined;

  // ========== é”™è¯¯é’©å­ ==========

  /**
   * é”™è¯¯å‘ç”Ÿæ—¶è§¦å‘
   */
  onError?: (
    context: WaterfallPluginContext<T>,
    error: Error,
    errorInfo?: React.ErrorInfo
  ) => void;

  /**
   * é¡¹åŠ è½½å¤±è´¥æ—¶è§¦å‘
   */
  onItemLoadError?: (
    context: WaterfallPluginContext<T>,
    index: number,
    error: Error
  ) => void;

  // ========== æ¸²æŸ“é’©å­ ==========

  /**
   * è‡ªå®šä¹‰å®¹å™¨æ¸²æŸ“
   */
  renderContainer?: (
    context: WaterfallPluginContext<T>,
    children: React.ReactNode
  ) => React.ReactNode;

  /**
   * è‡ªå®šä¹‰é¡¹åŒ…è£…å™¨æ¸²æŸ“
   */
  renderItemWrapper?: (
    context: WaterfallPluginContext<T>,
    index: number,
    item: T,
    children: React.ReactNode
  ) => React.ReactNode;

  /**
   * è‡ªå®šä¹‰è¦†ç›–å±‚æ¸²æŸ“ï¼ˆåŠ è½½çŠ¶æ€ã€ç©ºçŠ¶æ€ç­‰ï¼‰
   */
  renderOverlay?: (context: WaterfallPluginContext<T>) => React.ReactNode;

  /**
   * è‡ªå®šä¹‰åŠ è½½æ›´å¤šæŒ‡ç¤ºå™¨
   */
  renderLoadingMore?: (context: WaterfallPluginContext<T>) => React.ReactNode;

  /**
   * è‡ªå®šä¹‰ç©ºçŠ¶æ€
   */
  renderEmpty?: (context: WaterfallPluginContext<T>) => React.ReactNode;

  /**
   * è‡ªå®šä¹‰é”™è¯¯çŠ¶æ€
   */
  renderError?: (
    context: WaterfallPluginContext<T>,
    error: Error
  ) => React.ReactNode;

  // ========== Props è½¬æ¢é’©å­ ==========

  /**
   * è½¬æ¢ Propsï¼ˆå¯ä»¥åœ¨ç»„ä»¶æ¥æ”¶ props å‰ä¿®æ”¹ï¼‰
   */
  transformProps?: (props: WaterfallCoreProps<T>) => WaterfallCoreProps<T>;

  /**
   * è½¬æ¢é¡¹æ•°æ®ï¼ˆå¯ä»¥åœ¨æ¸²æŸ“å‰ä¿®æ”¹é¡¹æ•°æ®ï¼‰
   */
  transformItem?: (
    context: WaterfallPluginContext<T>,
    item: T,
    index: number
  ) => T;
}

// ============ æ’ä»¶å®šä¹‰ ============

export interface WaterfallPlugin<T = any> {
  /**
   * æ’ä»¶åç§°ï¼ˆå”¯ä¸€æ ‡è¯†ï¼‰
   */
  name: string;

  /**
   * æ’ä»¶ç‰ˆæœ¬
   */
  version?: string;

  /**
   * æ’ä»¶æè¿°
   */
  description?: string;

  /**
   * æ’ä»¶é’©å­
   */
  hooks: WaterfallPluginHooks<T>;

  /**
   * æ’ä»¶é…ç½®
   */
  config?: Record<string, any>;

  /**
   * æ’ä»¶ä¾èµ–ï¼ˆéœ€è¦å…ˆåŠ è½½çš„æ’ä»¶åç§°ï¼‰
   */
  dependencies?: string[];

  /**
   * æ’ä»¶ä¼˜å…ˆçº§ï¼ˆæ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜ï¼‰
   */
  priority?: number;

  /**
   * æ’ä»¶åˆå§‹åŒ–
   */
  init?: () => void | Promise<void>;

  /**
   * æ’ä»¶é”€æ¯
   */
  destroy?: () => void | Promise<void>;

  /**
   * æ’ä»¶æ˜¯å¦å¯ç”¨
   */
  enabled?: boolean;
}

// ============ æ’ä»¶ç®¡ç†å™¨ ============

export interface PluginManager<T = any> {
  /**
   * æ³¨å†Œæ’ä»¶
   */
  register: (plugin: WaterfallPlugin<T>) => void;

  /**
   * æ‰¹é‡æ³¨å†Œæ’ä»¶
   */
  registerAll: (plugins: WaterfallPlugin<T>[]) => void;

  /**
   * æ³¨é”€æ’ä»¶
   */
  unregister: (pluginName: string) => void;

  /**
   * è·å–æ’ä»¶
   */
  getPlugin: (pluginName: string) => WaterfallPlugin<T> | undefined;

  /**
   * è·å–æ‰€æœ‰æ’ä»¶
   */
  getAllPlugins: () => WaterfallPlugin<T>[];

  /**
   * è·å–å¯ç”¨çš„æ’ä»¶
   */
  getEnabledPlugins: () => WaterfallPlugin<T>[];

  /**
   * å¯ç”¨æ’ä»¶
   */
  enablePlugin: (pluginName: string) => void;

  /**
   * ç¦ç”¨æ’ä»¶
   */
  disablePlugin: (pluginName: string) => void;

  /**
   * æ£€æŸ¥æ’ä»¶æ˜¯å¦å·²æ³¨å†Œ
   */
  hasPlugin: (pluginName: string) => boolean;

  /**
   * æ‰§è¡Œé’©å­
   */
  executeHook: <K extends keyof WaterfallPluginHooks<T>>(
    hookName: K,
    context: WaterfallPluginContext<T>,
    ...args: any[]
  ) => Promise<any>;

  /**
   * æ¸…ç©ºæ‰€æœ‰æ’ä»¶
   */
  clear: () => void;
}

// ============ å·¥å…·ç±»å‹ ============

/**
 * æ’ä»¶åˆ›å»ºå™¨ç±»å‹
 */
export type PluginCreator<T = any, Config = any> = (
  config?: Config
) => WaterfallPlugin<T>;

/**
 * é¡¹æ¸²æŸ“å‡½æ•°ç±»å‹
 */
export type ItemRenderer<T = any> = (
  item: T,
  index: number,
  context: WaterfallPluginContext<T>
) => React.ReactNode;

/**
 * é¡¹é”®æå–å‡½æ•°ç±»å‹
 */
export type ItemKeyExtractor<T = any> = (
  item: T,
  index: number
) => string | number;
```

## ğŸ¯ ç¬¬ä¸‰æ­¥ï¼šæ ¸å¿ƒç»„ä»¶ `core/WaterfallCore.tsx`

```typescript
/**
 * WaterfallCore - ç€‘å¸ƒæµæ ¸å¿ƒç»„ä»¶
 *
 * èŒè´£ï¼š
 * 1. ç®¡ç†ç€‘å¸ƒæµå¸ƒå±€è®¡ç®—
 * 2. å¤„ç†æ»šåŠ¨å’Œå°ºå¯¸å˜åŒ–
 * 3. ç»´æŠ¤é¡¹ä½ç½®æ˜ å°„
 * 4. æä¾›ç”Ÿå‘½å‘¨æœŸé’©å­
 * 5. ç®¡ç† DOM å¼•ç”¨
 *
 * è®¾è®¡åŸåˆ™ï¼š
 * - ä¿æŒæ ¸å¿ƒåŠŸèƒ½ç®€å•çº¯ç²¹
 * - æ‰€æœ‰æ‰©å±•åŠŸèƒ½é€šè¿‡æ’ä»¶å®ç°
 * - æä¾›å®Œæ•´çš„ä¸Šä¸‹æ–‡ä¾›æ’ä»¶ä½¿ç”¨
 */

import React, {
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from "react";
import type {
  ItemPosition,
  LayoutInfo,
  ViewportInfo,
  ItemKeyExtractor,
} from "../plugins/types";

// ============ Props å®šä¹‰ ============

export interface WaterfallCoreProps<T = any> {
  // ===== æ•°æ®ç›¸å…³ =====
  /**
   * æ•°æ®æº
   */
  items: T[];

  /**
   * æ¸²æŸ“å‡½æ•°
   */
  renderItem: (item: T, index: number) => React.ReactNode;

  /**
   * é”®æå–å‡½æ•°ï¼ˆç”¨äº React keyï¼‰
   */
  keyExtractor?: ItemKeyExtractor<T>;

  // ===== å¸ƒå±€é…ç½® =====
  /**
   * åˆ—æ•°ï¼ˆå¯ç”±æ’ä»¶åŠ¨æ€è®¡ç®—ï¼‰
   */
  columns?: number;

  /**
   * åˆ—é—´è·
   */ gap?: number;

  /**
   * è¡Œé—´è·ï¼ˆå¯é€‰ï¼Œé»˜è®¤ç­‰äº gapï¼‰
   */
  rowGap?: number;

  /**
   * åˆ—é—´è·ï¼ˆå¯é€‰ï¼Œé»˜è®¤ç­‰äº gapï¼‰
   */
  columnGap?: number;

  /**
   * å®¹å™¨å†…è¾¹è·
   */
  padding?:
    | number
    | { top?: number; right?: number; bottom?: number; left?: number };

  // ===== æ ·å¼ç›¸å…³ =====
  /**
   * å®¹å™¨æ ·å¼
   */
  containerStyle?: React.CSSProperties;

  /**
   * å®¹å™¨ç±»å
   */
  containerClassName?: string;

  /**
   * é¡¹å®¹å™¨æ ·å¼
   */
  itemStyle?: React.CSSProperties;

  /**
   * é¡¹å®¹å™¨ç±»å
   */
  itemClassName?: string;

  // ===== æ€§èƒ½é…ç½® =====
  /**
   * æ˜¯å¦å¯ç”¨è™šæ‹Ÿæ»šåŠ¨ï¼ˆç”±æ’ä»¶æ§åˆ¶ï¼‰
   */
  virtual?: boolean;

  /**
   * é¢„ä¼°é¡¹é«˜åº¦ï¼ˆç”¨äºè™šæ‹Ÿæ»šåŠ¨ï¼‰
   */
  estimateItemHeight?: number;

  /**
   * é¢„æ¸²æŸ“é¡¹æ•°ï¼ˆè™šæ‹Ÿæ»šåŠ¨æ—¶ä¸Šä¸‹é¢å¤–æ¸²æŸ“çš„é¡¹æ•°ï¼‰
   */
  overscan?: number;

  /**
   * æ˜¯å¦ä½¿ç”¨ transform å®šä½ï¼ˆæ€§èƒ½æ›´å¥½ï¼‰
   */
  useTransform?: boolean;

  /**
   * èŠ‚æµå»¶è¿Ÿï¼ˆmsï¼‰
   */
  throttleDelay?: number;

  /**
   * é˜²æŠ–å»¶è¿Ÿï¼ˆmsï¼‰
   */
  debounceDelay?: number;

  // ===== ç”Ÿå‘½å‘¨æœŸé’©å­ï¼ˆç”±æ’ä»¶æ³¨å…¥ï¼‰ =====
  onMount?: () => void;
  onUnmount?: () => void;
  onBeforeLayout?: () => boolean | Promise<boolean>;
  onLayout?: () => void;
  onLayoutComplete?: () => void;
  onItemMount?: (index: number, element: HTMLElement) => void;
  onItemUnmount?: (index: number) => void;
  onItemEnterViewport?: (index: number) => void;
  onItemLeaveViewport?: (index: number) => void;
  onScroll?: (scrollTop: number, scrollLeft: number) => void;
  onResize?: (width: number, height: number) => void;
  onReachBottom?: (distance: number) => void;
  onItemClick?: (index: number, item: T, event: React.MouseEvent) => void;

  // ===== æ‰©å±•åŠŸèƒ½ =====
  /**
   * å­å…ƒç´ ï¼ˆç”¨äºæ’ä»¶æ¸²æŸ“è¦†ç›–å±‚ç­‰ï¼‰
   */
  children?: React.ReactNode;

  /**
   * å¤–éƒ¨å®¹å™¨å¼•ç”¨ï¼ˆä¾› HOC ä¼ å…¥ï¼‰
   */
  containerRefExternal?: React.RefObject<HTMLDivElement | null>;

  /**
   * å¤–éƒ¨é¡¹å¼•ç”¨æ˜ å°„ï¼ˆä¾› HOC ä¼ å…¥ï¼‰
   */
  itemRefsExternal?: React.MutableRefObject<Map<number, HTMLElement>>;

  /**
   * æ˜¯å¦å¯ç”¨è°ƒè¯•æ¨¡å¼
   */
  debug?: boolean;
}

// ============ Ref æš´éœ²æ¥å£ ============

export interface WaterfallCoreRef {
  /**
   * é‡æ–°å¸ƒå±€
   */
  relayout: () => void;

  /**
   * æ»šåŠ¨åˆ°æŒ‡å®šé¡¹
   */
  scrollToItem: (index: number, options?: ScrollToItemOptions) => void;

  /**
   * æ»šåŠ¨åˆ°é¡¶éƒ¨
   */
  scrollToTop: (options?: ScrollToOptions) => void;

  /**
   * æ»šåŠ¨åˆ°åº•éƒ¨
   */
  scrollToBottom: (options?: ScrollToOptions) => void;

  /**
   * è·å–é¡¹ä½ç½®
   */
  getItemPosition: (index: number) => ItemPosition | null;

  /**
   * è·å–æ‰€æœ‰é¡¹ä½ç½®
   */
  getAllItemPositions: () => Map<number, ItemPosition>;

  /**
   * è·å–åˆ—é«˜åº¦
   */
  getColumnHeights: () => number[];

  /**
   * è·å–å¸ƒå±€ä¿¡æ¯
   */
  getLayoutInfo: () => LayoutInfo;

  /**
   * è·å–è§†å£ä¿¡æ¯
   */
  getViewportInfo: () => ViewportInfo;

  /**
   * è·å–å¯è§é¡¹ç´¢å¼•
   */
  getVisibleItems: () => Set<number>;

  /**
   * å¼ºåˆ¶æ›´æ–°
   */
  forceUpdate: () => void;

  /**
   * è·å–å®¹å™¨ DOM
   */
  getContainer: () => HTMLDivElement | null;

  /**
   * è·å–é¡¹ DOM
   */
  getItemElement: (index: number) => HTMLElement | null;

  /**
   * æµ‹é‡é¡¹å°ºå¯¸
   */
  measureItem: (index: number) => Promise<{ width: number; height: number }>;
}

export interface ScrollToItemOptions {
  behavior?: "auto" | "smooth";
  block?: "start" | "center" | "end" | "nearest";
  inline?: "start" | "center" | "end" | "nearest";
  offset?: number; // é¢å¤–åç§»
}

export interface ScrollToOptions {
  behavior?: "auto" | "smooth";
  offset?: number;
}

// ============ æ ¸å¿ƒç»„ä»¶å®ç° ============

const WaterfallCore = forwardRef<WaterfallCoreRef, WaterfallCoreProps>(
  function WaterfallCore<T = any>(
    props: WaterfallCoreProps<T>,
    ref: React.ForwardedRef<WaterfallCoreRef>
  ) {
    const {
      items = [],
      renderItem,
      keyExtractor = (item, index) => index,
      columns = 3,
      gap = 16,
      rowGap,
      columnGap,
      padding = 0,
      containerStyle,
      containerClassName,
      itemStyle,
      itemClassName,
      virtual = false,
      estimateItemHeight = 300,
      overscan = 2,
      useTransform = true,
      throttleDelay = 16,
      debounceDelay = 150,
      onMount,
      onUnmount,
      onBeforeLayout,
      onLayout,
      onLayoutComplete,
      onItemMount,
      onItemUnmount,
      onItemEnterViewport,
      onItemLeaveViewport,
      onScroll,
      onResize,
      onReachBottom,
      onItemClick,
      children,
      containerRefExternal,
      itemRefsExternal,
      debug = false,
    } = props;

    // ===== Refs =====
    const containerRef = containerRefExternal || useRef<HTMLDivElement>(null);
    const itemRefsMap =
      itemRefsExternal || useRef<Map<number, HTMLElement>>(new Map());
    const resizeObserverRef = useRef<ResizeObserver | null>(null);
    const scrollTimerRef = useRef<number>();
    const layoutTimerRef = useRef<number>();

    // ===== State =====
    const [layoutInfo, setLayoutInfo] = useState<LayoutInfo>({
      columns,
      columnWidth: 0,
      gap: columnGap || gap,
      columnHeights: Array(columns).fill(0),
      totalHeight: 0,
      containerWidth: 0,
      containerHeight: 0,
    });

    const [itemPositions, setItemPositions] = useState<
      Map<number, ItemPosition>
    >(new Map());

    const [viewportInfo, setViewportInfo] = useState<ViewportInfo>({
      scrollTop: 0,
      scrollLeft: 0,
      scrollHeight: 0,
      scrollWidth: 0,
      clientHeight: 0,
      clientWidth: 0,
      isScrolling: false,
      direction: null,
    });

    const [visibleItems, setVisibleItems] = useState<Set<number>>(new Set());
    const [, forceUpdateState] = useState({});

    // ===== è®¡ç®—å†…è¾¹è· =====
    const paddingValues = useMemo(() => {
      if (typeof padding === "number") {
        return { top: padding, right: padding, bottom: padding, left: padding };
      }
      return {
        top: padding.top || 0,
        right: padding.right || 0,
        bottom: padding.bottom || 0,
        left: padding.left || 0,
      };
    }, [padding]);

    // ===== è®¡ç®—é—´è· =====
    const rowGapValue = rowGap !== undefined ? rowGap : gap;
    const columnGapValue = columnGap !== undefined ? columnGap : gap;

    // ===== å¸ƒå±€è®¡ç®— =====
    const calculateLayout = useCallback(async () => {
      const container = containerRef.current;
      if (!container || items.length === 0) return;

      // è§¦å‘ onBeforeLayout é’©å­
      if (onBeforeLayout) {
        const shouldContinue = await onBeforeLayout();
        if (!shouldContinue) return;
      }

      if (debug) console.time("[WaterfallCore] Layout calculation");

      const containerWidth = container.clientWidth;
      const contentWidth =
        containerWidth - paddingValues.left - paddingValues.right;
      const columnWidth =
        (contentWidth - columnGapValue * (columns - 1)) / columns;

      const columnHeights = Array(columns).fill(paddingValues.top);
      const newPositions = new Map<number, ItemPosition>();

      // è§¦å‘ onLayout é’©å­
      if (onLayout) onLayout();

      // è®¡ç®—æ¯ä¸ªé¡¹çš„ä½ç½®
      for (let i = 0; i < items.length; i++) {
        const itemElement = itemRefsMap.current.get(i);
        let itemHeight = estimateItemHeight;

        // å°è¯•è·å–å®é™…é«˜åº¦
        if (itemElement) {
          itemHeight = itemElement.offsetHeight || estimateItemHeight;
        }

        // æ‰¾åˆ°æœ€çŸ­çš„åˆ—
        const shortestColumnIndex = columnHeights.indexOf(
          Math.min(...columnHeights)
        );
        const column = shortestColumnIndex;
        const x = paddingValues.left + column * (columnWidth + columnGapValue);
        const y = columnHeights[column];

        newPositions.set(i, {
          x,
          y,
          width: columnWidth,
          height: itemHeight,
          column,
          row: Math.floor(i / columns),
        });

        // æ›´æ–°åˆ—é«˜åº¦
        columnHeights[column] += itemHeight + rowGapValue;
      }

      const totalHeight = Math.max(...columnHeights) + paddingValues.bottom;

      setLayoutInfo({
        columns,
        columnWidth,
        gap: columnGapValue,
        columnHeights,
        totalHeight,
        containerWidth,
        containerHeight: container.clientHeight,
      });

      setItemPositions(newPositions);

      // è§¦å‘ onLayoutComplete é’©å­
      if (onLayoutComplete) onLayoutComplete();

      if (debug) {
        console.timeEnd("[WaterfallCore] Layout calculation");
        console.log("[WaterfallCore] Layout info:", {
          columns,
          columnWidth,
          totalHeight,
          itemCount: items.length,
        });
      }
    }, [
      items,
      columns,
      columnGapValue,
      rowGapValue,
      paddingValues,
      estimateItemHeight,
      onBeforeLayout,
      onLayout,
      onLayoutComplete,
      debug,
    ]);

    // ===== èŠ‚æµçš„å¸ƒå±€è®¡ç®— =====
    const throttledCalculateLayout = useCallback(() => {
      if (layoutTimerRef.current) {
        window.clearTimeout(layoutTimerRef.current);
      }
      layoutTimerRef.current = window.setTimeout(() => {
        calculateLayout();
      }, debounceDelay);
    }, [calculateLayout, debounceDelay]);

    // ===== æ›´æ–°è§†å£ä¿¡æ¯ =====
    const updateViewportInfo = useCallback(() => {
      const container = containerRef.current;
      if (!container) return;

      const prevScrollTop = viewportInfo.scrollTop;
      const newScrollTop = container.scrollTop;
      const direction =
        newScrollTop > prevScrollTop
          ? "down"
          : newScrollTop < prevScrollTop
          ? "up"
          : null;

      setViewportInfo({
        scrollTop: newScrollTop,
        scrollLeft: container.scrollLeft,
        scrollHeight: container.scrollHeight,
        scrollWidth: container.scrollWidth,
        clientHeight: container.clientHeight,
        clientWidth: container.clientWidth,
        isScrolling: true,
        direction,
      });
    }, [viewportInfo.scrollTop]);

    // ===== è®¡ç®—å¯è§é¡¹ =====
    const calculateVisibleItems = useCallback(() => {
      const container = containerRef.current;
      if (!container) return;

      const scrollTop = container.scrollTop;
      const clientHeight = container.clientHeight;
      const viewportTop = scrollTop - overscan * estimateItemHeight;
      const viewportBottom =
        scrollTop + clientHeight + overscan * estimateItemHeight;

      const newVisibleItems = new Set<number>();
      const prevVisibleItems = new Set(visibleItems);

      itemPositions.forEach((position, index) => {
        const itemTop = position.y;
        const itemBottom = position.y + position.height;

        if (itemBottom >= viewportTop && itemTop <= viewportBottom) {
          newVisibleItems.add(index);

          // è§¦å‘è¿›å…¥è§†å£äº‹ä»¶
          if (!prevVisibleItems.has(index) && onItemEnterViewport) {
            onItemEnterViewport(index);
          }
        } else if (prevVisibleItems.has(index) && onItemLeaveViewport) {
          // è§¦å‘ç¦»å¼€è§†å£äº‹ä»¶
          onItemLeaveViewport(index);
        }
      });

      setVisibleItems(newVisibleItems);
    }, [
      itemPositions,
      overscan,
      estimateItemHeight,
      visibleItems,
      onItemEnterViewport,
      onItemLeaveViewport,
    ]);

    // ===== æ»šåŠ¨å¤„ç† =====
    const handleScroll = useCallback(() => {
      updateViewportInfo();
      calculateVisibleItems();

      const container = containerRef.current;
      if (!container) return;

      // è§¦å‘ onScroll é’©å­
      if (onScroll) {
        onScroll(container.scrollTop, container.scrollLeft);
      }

      // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾åº•éƒ¨
      if (onReachBottom) {
        const scrollTop = container.scrollTop;
        const scrollHeight = container.scrollHeight;
        const clientHeight = container.clientHeight;
        const distanceToBottom = scrollHeight - (scrollTop + clientHeight);

        if (distanceToBottom < 100) {
          onReachBottom(distanceToBottom);
        }
      }

      // æ ‡è®°æ»šåŠ¨ç»“æŸ
      if (scrollTimerRef.current) {
        window.clearTimeout(scrollTimerRef.current);
      }
      scrollTimerRef.current = window.setTimeout(() => {
        setViewportInfo((prev) => ({ ...prev, isScrolling: false }));
      }, 150);
    }, [updateViewportInfo, calculateVisibleItems, onScroll, onReachBottom]);

    // ===== å°ºå¯¸å˜åŒ–å¤„ç† =====
    const handleResize = useCallback(
      (entries: ResizeObserverEntry[]) => {
        const container = entries[0]?.target as HTMLDivElement;
        if (!container) return;

        const width = container.clientWidth;
        const height = container.clientHeight;

        if (onResize) {
          onResize(width, height);
        }

        throttledCalculateLayout();
      },
      [onResize, throttledCalculateLayout]
    );

    // ===== æŒ‚è½½æ—¶ =====
    useEffect(() => {
      if (onMount) onMount();

      // åˆå§‹å¸ƒå±€
      calculateLayout();

      // ç›‘å¬å®¹å™¨å°ºå¯¸å˜åŒ–
      const container = containerRef.current;
      if (container) {
        resizeObserverRef.current = new ResizeObserver(handleResize);
        resizeObserverRef.current.observe(container);
      }

      return () => {
        if (onUnmount) onUnmount();
        if (resizeObserverRef.current) {
          resizeObserverRef.current.disconnect();
        }
        if (scrollTimerRef.current) {
          window.clearTimeout(scrollTimerRef.current);
        }
        if (layoutTimerRef.current) {
          window.clearTimeout(layoutTimerRef.current);
        }
      };
    }, []);

    // ===== items å˜åŒ–æ—¶é‡æ–°å¸ƒå±€ =====
    useEffect(() => {
      throttledCalculateLayout();
    }, [items, throttledCalculateLayout]);

    // ===== columns å˜åŒ–æ—¶é‡æ–°å¸ƒå±€ =====
    useEffect(() => {
      calculateLayout();
    }, [columns]);

    // ===== æš´éœ²æ–¹æ³• =====
    useImperativeHandle(ref, () => ({
      relayout: calculateLayout,
      scrollToItem: (index, options = {}) => {
        const position = itemPositions.get(index);
        if (!position || !containerRef.current) return;

        const container = containerRef.current;
        const offset = options.offset || 0;
        let scrollTop = position.y + offset;

        if (options.block === "center") {
          scrollTop -= container.clientHeight / 2 - position.height / 2;
        } else if (options.block === "end") {
          scrollTop -= container.clientHeight - position.height;
        }

        container.scrollTo({
          top: Math.max(0, scrollTop),
          behavior: options.behavior || "auto",
        });
      },
      scrollToTop: (options = {}) => {
        containerRef.current?.scrollTo({
          top: options.offset || 0,
          behavior: options.behavior || "auto",
        });
      },
      scrollToBottom: (options = {}) => {
        const container = containerRef.current;
        if (!container) return;
        container.scrollTo({
          top:
            container.scrollHeight -
            container.clientHeight +
            (options.offset || 0),
          behavior: options.behavior || "auto",
        });
      },
      getItemPosition: (index) => itemPositions.get(index) || null,
      getAllItemPositions: () => itemPositions,
      getColumnHeights: () => layoutInfo.columnHeights,
      getLayoutInfo: () => layoutInfo,
      getViewportInfo: () => viewportInfo,
      getVisibleItems: () => visibleItems,
      forceUpdate: () => forceUpdateState({}),
      getContainer: () => containerRef.current,
      getItemElement: (index) => itemRefsMap.current.get(index) || null,
      measureItem: async (index) => {
        const element = itemRefsMap.current.get(index);
        if (!element) {
          return { width: 0, height: 0 };
        }
        return {
          width: element.offsetWidth,
          height: element.offsetHeight,
        };
      },
    }));

    // ===== æ¸²æŸ“é¡¹ =====
    const renderItems = () => {
      // è™šæ‹Ÿæ»šåŠ¨ï¼šåªæ¸²æŸ“å¯è§é¡¹
      const itemsToRender = virtual
        ? Array.from(visibleItems)
        : items.map((_, i) => i);

      return itemsToRender.map((index) => {
        const item = items[index];
        if (!item) return null;

        const position = itemPositions.get(index);
        if (!position) return null;

        const key = keyExtractor(item, index);

        const itemPositionStyle: React.CSSProperties = useTransform
          ? {
              position: "absolute",
              transform: `translate(${position.x}px, ${position.y}px)`,
              width: position.width,
            }
          : {
              position: "absolute",
              left: position.x,
              top: position.y,
              width: position.width,
            };

        return (
          <div
            key={key}
            ref={(el) => {
              if (el) {
                itemRefsMap.current.set(index, el);
                if (onItemMount) onItemMount(index, el);
              } else {
                itemRefsMap.current.delete(index);
                if (onItemUnmount) onItemUnmount(index);
              }
            }}
            style={{
              ...itemPositionStyle,
              ...itemStyle,
            }}
            className={itemClassName}
            onClick={(e) => {
              if (onItemClick) onItemClick(index, item, e);
            }}
            data-index={index}
          >
            {renderItem(item, index)}
          </div>
        );
      });
    };

    // ===== æ¸²æŸ“ =====
    return (
      <div
        ref={containerRef}
        style={{
          position: "relative",
          overflow: "auto",
          ...containerStyle,
        }}
        className={containerClassName}
        onScroll={handleScroll}
      >
        {/* å ä½å®¹å™¨ï¼ˆç”¨äºæ’‘å¼€æ»šåŠ¨é«˜åº¦ï¼‰ */}
        <div
          style={{
            position: "relative",
            width: "100%",
            height: layoutInfo.totalHeight,
          }}
        >
          {renderItems()}
        </div>

        {/* æ’ä»¶è¦†ç›–å±‚ */}
        {children}
      </div>
    );
  }
);

export default WaterfallCore;
```

## ğŸ“¦ ç¬¬å››æ­¥ï¼šå…¶ä»–æ ¸å¿ƒæ–‡ä»¶æ¡†æ¶

### `plugins/PluginBus.ts`

```typescript
/**
 * PluginBus - æ’ä»¶äº‹ä»¶æ€»çº¿
 * ä¸ LazyLoadImagePlugin çš„ PluginBus ä¿æŒä¸€è‡´
 */
export function createPluginBus() {
  // ... å‚è€ƒ LazyLoadImagePlugin/plugins/PluginBus.ts å®ç°
}
```

### `plugins/PluginManager.ts`

```typescript
/**
 * PluginManager - æ’ä»¶ç®¡ç†å™¨
 * ä¸ LazyLoadImagePlugin çš„ PluginManager ä¿æŒä¸€è‡´
 */
export function createPluginManager() {
  // ... å‚è€ƒ LazyLoadImagePlugin/plugins/PluginManager.ts å®ç°
}
```

### `plugins/withPlugins.tsx`

```typescript
/**
 * withPlugins - HOC ç»„åˆå™¨
 * ä¸ LazyLoadImagePlugin çš„ withPlugins ä¿æŒä¸€è‡´
 */
export function withPlugins<T = any>(
  Component: React.ComponentType<WaterfallCoreProps<T>>,
  plugins: WaterfallPlugin<T>[]
) {
  // ... å‚è€ƒ LazyLoadImagePlugin/plugins/withPlugins.tsx å®ç°
}
```

### `index.ts` - ä¸»å…¥å£

```typescript
// WaterfallPlugin ç³»ç»Ÿå…¥å£
export { default as WaterfallCore } from "./core/WaterfallCore";
export type {
  WaterfallCoreProps,
  WaterfallCoreRef,
  ScrollToOptions,
  ScrollToItemOptions,
} from "./core/WaterfallCore";

// æ’ä»¶ç³»ç»Ÿ
export { withPlugins, createPluginBus, createPluginManager } from "./plugins";
export type {
  WaterfallPlugin,
  WaterfallPluginContext,
  WaterfallPluginHooks,
  PluginManager,
  ItemPosition,
  LayoutInfo,
  ViewportInfo,
  ItemVisibility,
  PerformanceMetrics,
} from "./plugins";

// è‡ªå®šä¹‰æ’ä»¶ï¼ˆæŒ‰éœ€å¯¼å‡ºï¼‰
export * from "./custom-plugins";
```

è¿™ä¸ªè®¾è®¡æ–¹æ¡ˆï¼š
âœ… ä¸ LazyLoadImagePlugin æ¶æ„å®Œå…¨ä¸€è‡´
âœ… ç±»å‹å®šä¹‰å®Œæ•´ä¸”è€ƒè™‘äº†å„ç§åœºæ™¯
âœ… æ ¸å¿ƒç»„ä»¶èŒè´£æ¸…æ™°
âœ… æ‰©å±•æ€§å¼ºï¼Œæ˜“äºæ·»åŠ æ–°æ’ä»¶
âœ… æ€§èƒ½ä¼˜åŒ–ï¼ˆè™šæ‹Ÿæ»šåŠ¨ã€èŠ‚æµã€é˜²æŠ–ï¼‰
âœ… æä¾›å®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸé’©å­

éœ€è¦æˆ‘ç»§ç»­è®¾è®¡å…·ä½“çš„æ’ä»¶å®ç°å—ï¼Ÿ

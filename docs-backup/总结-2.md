好的！我来为你设计一个完整、全面的 WaterfallPlugin 系统，保持与 LazyLoadImagePlugin 一致的代码结构和标准。

## 📁 第一步：目录结构规划

```
src/components/WaterfallPlugin/
├── core/
│   └── WaterfallCore.tsx           # 核心瀑布流组件
├── plugins/
│   ├── types.ts                     # 插件类型定义（核心）
│   ├── PluginBus.ts                 # 事件总线
│   ├── PluginManager.ts             # 插件管理器
│   ├── withPlugins.tsx              # HOC 组合器
│   └── index.ts                     # 插件系统导出
├── custom-plugins/
│   ├── ResponsiveColumnsPlugin/
│   │   ├── index.ts
│   │   └── README.md
│   ├── VirtualScrollPlugin/
│   │   ├── index.ts
│   │   └── README.md
│   ├── InfiniteScrollPlugin/
│   │   ├── index.ts
│   │   └── README.md
│   ├── AnimationPlugin/
│   │   ├── index.ts
│   │   └── README.md
│   ├── LazyLoadPlugin/
│   │   ├── index.ts
│   │   └── README.md
│   ├── FilterPlugin/
│   │   ├── index.ts
│   │   └── README.md
│   ├── SortPlugin/
│   │   ├── index.ts
│   │   └── README.md
│   ├── SelectionPlugin/
│   │   ├── index.ts
│   │   └── README.md
│   └── index.ts                     # 统一导出所有插件
└── index.ts                         # 主入口
```

## 📝 第二步：核心类型定义 `plugins/types.ts`

```typescript
/**
 * WaterfallPlugin 插件系统类型定义
 * 参考 LazyLoadImagePlugin 架构设计
 */

import type React from "react";
import type { WaterfallCoreProps } from "../core/WaterfallCore";

// ============ 基础数据类型 ============

/**
 * 瀑布流项的位置信息
 */
export interface ItemPosition {
  x: number;
  y: number;
  width: number;
  height: number;
  column: number; // 所属列
  row: number; // 所属行（虚拟行概念）
}

/**
 * 布局信息
 */
export interface LayoutInfo {
  columns: number; // 当前列数
  columnWidth: number; // 列宽
  gap: number; // 间距
  columnHeights: number[]; // 每列的高度
  totalHeight: number; // 总高度
  containerWidth: number; // 容器宽度
  containerHeight: number; // 容器高度
}

/**
 * 视口信息
 */
export interface ViewportInfo {
  scrollTop: number;
  scrollLeft: number;
  scrollHeight: number;
  scrollWidth: number;
  clientHeight: number;
  clientWidth: number;
  isScrolling: boolean;
  direction: "up" | "down" | "left" | "right" | null;
}

/**
 * 项可见性信息
 */
export interface ItemVisibility {
  index: number;
  isVisible: boolean;
  visibleRatio: number; // 0-1
  isAboveViewport: boolean;
  isBelowViewport: boolean;
}

/**
 * 性能指标
 */
export interface PerformanceMetrics {
  // 布局相关
  layoutStartTime: number;
  layoutEndTime?: number;
  layoutDuration?: number;
  layoutCount: number;

  // 渲染相关
  renderStartTime?: number;
  renderEndTime?: number;
  renderDuration?: number;
  renderedItemCount: number;

  // 滚动相关
  scrollStartTime?: number;
  scrollEndTime?: number;
  scrollDuration?: number;
  scrollDistance?: number;

  // 内存相关
  itemCount: number;
  visibleItemCount: number;
  memoryUsage?: number;
}

/**
 * 设备信息
 */
export interface DeviceInfo {
  type: "mobile" | "tablet" | "desktop";
  os: string;
  browser: string;
  devicePixelRatio: number;
  viewportWidth: number;
  viewportHeight: number;
  isTouchDevice: boolean;
  isRetina: boolean;
}

/**
 * 网络信息
 */
export interface NetworkInfo {
  effectiveType: "4g" | "3g" | "2g" | "slow-2g";
  downlink: number; // Mbps
  rtt: number; // ms
  saveData: boolean;
  online: boolean;
}

/**
 * 动画配置
 */
export interface AnimationConfig {
  duration: number;
  delay?: number;
  easing?: string;
  stagger?: number; // 交错延迟
}

/**
 * 拖拽信息
 */
export interface DragInfo {
  isDragging: boolean;
  draggedIndex: number | null;
  dragStartX: number;
  dragStartY: number;
  dragCurrentX: number;
  dragCurrentY: number;
  dropTargetIndex: number | null;
}

// ============ 插件通信总线 ============

export interface PluginBus {
  // 事件发布订阅
  emit: <T = any>(event: string, data?: T) => void;
  on: <T = any>(event: string, handler: (data: T) => void) => () => void;
  once: <T = any>(event: string, handler: (data: T) => void) => () => void;
  off: (event: string, handler?: Function) => void;

  // 数据共享
  getData: <T = any>(key: string) => T | undefined;
  setData: <T = any>(key: string, value: T) => void;
  deleteData: (key: string) => void;
  hasData: (key: string) => boolean;

  // 批量操作
  getAll: () => Record<string, any>;
  clear: () => void;
}

// ============ 插件上下文 ============

export interface WaterfallPluginContext<T = any> {
  // 基础数据
  items: T[];
  itemCount: number;

  // DOM 引用
  containerRef: React.RefObject<HTMLDivElement | null>;
  itemRefs: Map<number, HTMLElement>;
  getItemRef: (index: number) => HTMLElement | null;

  // 布局信息
  layout: LayoutInfo;
  itemPositions: Map<number, ItemPosition>;
  getItemPosition: (index: number) => ItemPosition | null;

  // 视口信息
  viewport: ViewportInfo;
  visibleItems: Set<number>; // 当前可见的项索引集合
  visibleRange: { start: number; end: number }; // 可见范围

  // 状态
  isLayouting: boolean;
  isScrolling: boolean;
  isDragging: boolean;
  isLoading: boolean;
  hasMore: boolean;
  error: Error | null;

  // 配置
  props: WaterfallCoreProps<T>;

  // 插件通信
  bus?: PluginBus;
  sharedData?: Map<string, any>;

  // 扩展信息
  deviceInfo?: DeviceInfo;
  networkInfo?: NetworkInfo;
  performanceMetrics?: PerformanceMetrics;
  dragInfo?: DragInfo;

  // 工具方法
  relayout: () => void;
  scrollToItem: (index: number, options?: ScrollToOptions) => void;
  scrollToTop: (options?: ScrollToOptions) => void;
  scrollToBottom: (options?: ScrollToOptions) => void;
  measureItem: (index: number) => Promise<{ width: number; height: number }>;
  forceUpdate: () => void;
}

export interface ScrollToOptions {
  behavior?: "auto" | "smooth";
  block?: "start" | "center" | "end" | "nearest";
  inline?: "start" | "center" | "end" | "nearest";
}

// ============ 插件钩子定义 ============

export interface WaterfallPluginHooks<T = any> {
  // ========== 生命周期钩子 ==========

  /**
   * 组件挂载时触发
   * @returns 清理函数（可选）
   */
  onMount?: (context: WaterfallPluginContext<T>) => void | (() => void);

  /**
   * 组件卸载时触发
   */
  onUnmount?: (context: WaterfallPluginContext<T>) => void;

  /**
   * Props 变化时触发
   */
  onPropsChange?: (
    context: WaterfallPluginContext<T>,
    prevProps: WaterfallCoreProps<T>,
    nextProps: WaterfallCoreProps<T>
  ) => void;

  // ========== 布局钩子 ==========

  /**
   * 布局开始前触发
   * @returns false 可以阻止布局
   */
  onBeforeLayout?: (
    context: WaterfallPluginContext<T>
  ) => boolean | Promise<boolean>;

  /**
   * 布局计算中触发（可以修改布局逻辑）
   */
  onLayout?: (context: WaterfallPluginContext<T>) => void;

  /**
   * 布局完成后触发
   */
  onLayoutComplete?: (context: WaterfallPluginContext<T>) => void;

  /**
   * 计算列数（响应式插件会实现此钩子）
   * @returns 列数，undefined 表示使用默认值
   */
  calculateColumns?: (context: WaterfallPluginContext<T>) => number | undefined;

  /**
   * 计算列宽（自定义列宽插件会实现）
   */
  calculateColumnWidth?: (
    context: WaterfallPluginContext<T>,
    containerWidth: number,
    columns: number
  ) => number | undefined;

  /**
   * 计算项位置（自定义布局算法插件会实现）
   */
  calculateItemPosition?: (
    context: WaterfallPluginContext<T>,
    index: number,
    itemHeight: number
  ) => ItemPosition | undefined;

  // ========== 项生命周期钩子 ==========

  /**
   * 项挂载时触发
   */
  onItemMount?: (
    context: WaterfallPluginContext<T>,
    index: number,
    element: HTMLElement
  ) => void;

  /**
   * 项卸载时触发
   */
  onItemUnmount?: (context: WaterfallPluginContext<T>, index: number) => void;

  /**
   * 项进入视口时触发
   */
  onItemEnterViewport?: (
    context: WaterfallPluginContext<T>,
    index: number,
    visibility: ItemVisibility
  ) => void;

  /**
   * 项离开视口时触发
   */
  onItemLeaveViewport?: (
    context: WaterfallPluginContext<T>,
    index: number,
    visibility: ItemVisibility
  ) => void;

  /**
   * 项可见性变化时触发
   */
  onItemVisibilityChange?: (
    context: WaterfallPluginContext<T>,
    index: number,
    visibility: ItemVisibility
  ) => void;

  /**
   * 项点击时触发
   */
  onItemClick?: (
    context: WaterfallPluginContext<T>,
    index: number,
    item: T,
    event: React.MouseEvent
  ) => void;

  // ========== 滚动钩子 ==========

  /**
   * 滚动开始时触发
   */
  onScrollStart?: (context: WaterfallPluginContext<T>) => void;

  /**
   * 滚动中触发
   */
  onScroll?: (
    context: WaterfallPluginContext<T>,
    scrollTop: number,
    scrollLeft: number
  ) => void;

  /**
   * 滚动结束时触发
   */
  onScrollEnd?: (context: WaterfallPluginContext<T>) => void;

  /**
   * 滚动到底部时触发（用于无限滚动）
   */
  onReachBottom?: (
    context: WaterfallPluginContext<T>,
    distance: number
  ) => void | Promise<void>;

  /**
   * 滚动到顶部时触发
   */
  onReachTop?: (context: WaterfallPluginContext<T>) => void;

  // ========== 尺寸变化钩子 ==========

  /**
   * 容器尺寸变化时触发
   */
  onResize?: (
    context: WaterfallPluginContext<T>,
    width: number,
    height: number
  ) => void;

  /**
   * 项尺寸变化时触发
   */
  onItemResize?: (
    context: WaterfallPluginContext<T>,
    index: number,
    width: number,
    height: number
  ) => void;

  // ========== 数据钩子 ==========

  /**
   * 数据变化前触发
   * @returns false 可以阻止数据更新
   */
  onBeforeItemsChange?: (
    context: WaterfallPluginContext<T>,
    oldItems: T[],
    newItems: T[]
  ) => boolean | Promise<boolean>;

  /**
   * 数据变化后触发
   */
  onItemsChange?: (
    context: WaterfallPluginContext<T>,
    oldItems: T[],
    newItems: T[]
  ) => void;

  /**
   * 单个项数据变化时触发
   */
  onItemChange?: (
    context: WaterfallPluginContext<T>,
    index: number,
    oldItem: T,
    newItem: T
  ) => void;

  /**
   * 加载更多数据时触发（无限滚动插件会实现）
   */
  onLoadMore?: (
    context: WaterfallPluginContext<T>,
    page: number
  ) => Promise<T[]> | T[] | void;

  /**
   * 刷新数据时触发（下拉刷新插件会实现）
   */
  onRefresh?: (context: WaterfallPluginContext<T>) => Promise<T[]> | T[] | void;

  // ========== 交互钩子 ==========

  /**
   * 拖拽开始时触发
   */
  onDragStart?: (
    context: WaterfallPluginContext<T>,
    index: number,
    event: React.DragEvent
  ) => void;

  /**
   * 拖拽中触发
   */
  onDrag?: (
    context: WaterfallPluginContext<T>,
    index: number,
    event: React.DragEvent
  ) => void;

  /**
   * 拖拽结束时触发
   */
  onDragEnd?: (
    context: WaterfallPluginContext<T>,
    index: number,
    event: React.DragEvent
  ) => void;

  /**
   * 项被拖放时触发
   */
  onDrop?: (
    context: WaterfallPluginContext<T>,
    fromIndex: number,
    toIndex: number
  ) => void;

  /**
   * 项被选中时触发
   */
  onItemSelect?: (
    context: WaterfallPluginContext<T>,
    index: number,
    item: T,
    selected: boolean
  ) => void;

  /**
   * 多选变化时触发
   */
  onSelectionChange?: (
    context: WaterfallPluginContext<T>,
    selectedIndices: Set<number>
  ) => void;

  // ========== 筛选与排序钩子 ==========

  /**
   * 筛选逻辑（筛选插件会实现）
   */
  filterItem?: (
    context: WaterfallPluginContext<T>,
    item: T,
    index: number
  ) => boolean;

  /**
   * 排序逻辑（排序插件会实现）
   */
  sortItems?: (context: WaterfallPluginContext<T>, items: T[]) => T[];

  /**
   * 搜索逻辑（搜索插件会实现）
   */
  searchItem?: (
    context: WaterfallPluginContext<T>,
    item: T,
    query: string
  ) => boolean;

  // ========== 性能钩子 ==========

  /**
   * 性能指标收集
   */
  onPerformanceMetric?: (
    context: WaterfallPluginContext<T>,
    metrics: PerformanceMetrics
  ) => void;

  /**
   * 虚拟滚动范围计算（虚拟滚动插件会实现）
   */
  calculateVisibleRange?: (
    context: WaterfallPluginContext<T>
  ) => { start: number; end: number } | undefined;

  // ========== 错误钩子 ==========

  /**
   * 错误发生时触发
   */
  onError?: (
    context: WaterfallPluginContext<T>,
    error: Error,
    errorInfo?: React.ErrorInfo
  ) => void;

  /**
   * 项加载失败时触发
   */
  onItemLoadError?: (
    context: WaterfallPluginContext<T>,
    index: number,
    error: Error
  ) => void;

  // ========== 渲染钩子 ==========

  /**
   * 自定义容器渲染
   */
  renderContainer?: (
    context: WaterfallPluginContext<T>,
    children: React.ReactNode
  ) => React.ReactNode;

  /**
   * 自定义项包装器渲染
   */
  renderItemWrapper?: (
    context: WaterfallPluginContext<T>,
    index: number,
    item: T,
    children: React.ReactNode
  ) => React.ReactNode;

  /**
   * 自定义覆盖层渲染（加载状态、空状态等）
   */
  renderOverlay?: (context: WaterfallPluginContext<T>) => React.ReactNode;

  /**
   * 自定义加载更多指示器
   */
  renderLoadingMore?: (context: WaterfallPluginContext<T>) => React.ReactNode;

  /**
   * 自定义空状态
   */
  renderEmpty?: (context: WaterfallPluginContext<T>) => React.ReactNode;

  /**
   * 自定义错误状态
   */
  renderError?: (
    context: WaterfallPluginContext<T>,
    error: Error
  ) => React.ReactNode;

  // ========== Props 转换钩子 ==========

  /**
   * 转换 Props（可以在组件接收 props 前修改）
   */
  transformProps?: (props: WaterfallCoreProps<T>) => WaterfallCoreProps<T>;

  /**
   * 转换项数据（可以在渲染前修改项数据）
   */
  transformItem?: (
    context: WaterfallPluginContext<T>,
    item: T,
    index: number
  ) => T;
}

// ============ 插件定义 ============

export interface WaterfallPlugin<T = any> {
  /**
   * 插件名称（唯一标识）
   */
  name: string;

  /**
   * 插件版本
   */
  version?: string;

  /**
   * 插件描述
   */
  description?: string;

  /**
   * 插件钩子
   */
  hooks: WaterfallPluginHooks<T>;

  /**
   * 插件配置
   */
  config?: Record<string, any>;

  /**
   * 插件依赖（需要先加载的插件名称）
   */
  dependencies?: string[];

  /**
   * 插件优先级（数字越大优先级越高）
   */
  priority?: number;

  /**
   * 插件初始化
   */
  init?: () => void | Promise<void>;

  /**
   * 插件销毁
   */
  destroy?: () => void | Promise<void>;

  /**
   * 插件是否启用
   */
  enabled?: boolean;
}

// ============ 插件管理器 ============

export interface PluginManager<T = any> {
  /**
   * 注册插件
   */
  register: (plugin: WaterfallPlugin<T>) => void;

  /**
   * 批量注册插件
   */
  registerAll: (plugins: WaterfallPlugin<T>[]) => void;

  /**
   * 注销插件
   */
  unregister: (pluginName: string) => void;

  /**
   * 获取插件
   */
  getPlugin: (pluginName: string) => WaterfallPlugin<T> | undefined;

  /**
   * 获取所有插件
   */
  getAllPlugins: () => WaterfallPlugin<T>[];

  /**
   * 获取启用的插件
   */
  getEnabledPlugins: () => WaterfallPlugin<T>[];

  /**
   * 启用插件
   */
  enablePlugin: (pluginName: string) => void;

  /**
   * 禁用插件
   */
  disablePlugin: (pluginName: string) => void;

  /**
   * 检查插件是否已注册
   */
  hasPlugin: (pluginName: string) => boolean;

  /**
   * 执行钩子
   */
  executeHook: <K extends keyof WaterfallPluginHooks<T>>(
    hookName: K,
    context: WaterfallPluginContext<T>,
    ...args: any[]
  ) => Promise<any>;

  /**
   * 清空所有插件
   */
  clear: () => void;
}

// ============ 工具类型 ============

/**
 * 插件创建器类型
 */
export type PluginCreator<T = any, Config = any> = (
  config?: Config
) => WaterfallPlugin<T>;

/**
 * 项渲染函数类型
 */
export type ItemRenderer<T = any> = (
  item: T,
  index: number,
  context: WaterfallPluginContext<T>
) => React.ReactNode;

/**
 * 项键提取函数类型
 */
export type ItemKeyExtractor<T = any> = (
  item: T,
  index: number
) => string | number;
```

## 🎯 第三步：核心组件 `core/WaterfallCore.tsx`

```typescript
/**
 * WaterfallCore - 瀑布流核心组件
 *
 * 职责：
 * 1. 管理瀑布流布局计算
 * 2. 处理滚动和尺寸变化
 * 3. 维护项位置映射
 * 4. 提供生命周期钩子
 * 5. 管理 DOM 引用
 *
 * 设计原则：
 * - 保持核心功能简单纯粹
 * - 所有扩展功能通过插件实现
 * - 提供完整的上下文供插件使用
 */

import React, {
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from "react";
import type {
  ItemPosition,
  LayoutInfo,
  ViewportInfo,
  ItemKeyExtractor,
} from "../plugins/types";

// ============ Props 定义 ============

export interface WaterfallCoreProps<T = any> {
  // ===== 数据相关 =====
  /**
   * 数据源
   */
  items: T[];

  /**
   * 渲染函数
   */
  renderItem: (item: T, index: number) => React.ReactNode;

  /**
   * 键提取函数（用于 React key）
   */
  keyExtractor?: ItemKeyExtractor<T>;

  // ===== 布局配置 =====
  /**
   * 列数（可由插件动态计算）
   */
  columns?: number;

  /**
   * 列间距
   */ gap?: number;

  /**
   * 行间距（可选，默认等于 gap）
   */
  rowGap?: number;

  /**
   * 列间距（可选，默认等于 gap）
   */
  columnGap?: number;

  /**
   * 容器内边距
   */
  padding?:
    | number
    | { top?: number; right?: number; bottom?: number; left?: number };

  // ===== 样式相关 =====
  /**
   * 容器样式
   */
  containerStyle?: React.CSSProperties;

  /**
   * 容器类名
   */
  containerClassName?: string;

  /**
   * 项容器样式
   */
  itemStyle?: React.CSSProperties;

  /**
   * 项容器类名
   */
  itemClassName?: string;

  // ===== 性能配置 =====
  /**
   * 是否启用虚拟滚动（由插件控制）
   */
  virtual?: boolean;

  /**
   * 预估项高度（用于虚拟滚动）
   */
  estimateItemHeight?: number;

  /**
   * 预渲染项数（虚拟滚动时上下额外渲染的项数）
   */
  overscan?: number;

  /**
   * 是否使用 transform 定位（性能更好）
   */
  useTransform?: boolean;

  /**
   * 节流延迟（ms）
   */
  throttleDelay?: number;

  /**
   * 防抖延迟（ms）
   */
  debounceDelay?: number;

  // ===== 生命周期钩子（由插件注入） =====
  onMount?: () => void;
  onUnmount?: () => void;
  onBeforeLayout?: () => boolean | Promise<boolean>;
  onLayout?: () => void;
  onLayoutComplete?: () => void;
  onItemMount?: (index: number, element: HTMLElement) => void;
  onItemUnmount?: (index: number) => void;
  onItemEnterViewport?: (index: number) => void;
  onItemLeaveViewport?: (index: number) => void;
  onScroll?: (scrollTop: number, scrollLeft: number) => void;
  onResize?: (width: number, height: number) => void;
  onReachBottom?: (distance: number) => void;
  onItemClick?: (index: number, item: T, event: React.MouseEvent) => void;

  // ===== 扩展功能 =====
  /**
   * 子元素（用于插件渲染覆盖层等）
   */
  children?: React.ReactNode;

  /**
   * 外部容器引用（供 HOC 传入）
   */
  containerRefExternal?: React.RefObject<HTMLDivElement | null>;

  /**
   * 外部项引用映射（供 HOC 传入）
   */
  itemRefsExternal?: React.MutableRefObject<Map<number, HTMLElement>>;

  /**
   * 是否启用调试模式
   */
  debug?: boolean;
}

// ============ Ref 暴露接口 ============

export interface WaterfallCoreRef {
  /**
   * 重新布局
   */
  relayout: () => void;

  /**
   * 滚动到指定项
   */
  scrollToItem: (index: number, options?: ScrollToItemOptions) => void;

  /**
   * 滚动到顶部
   */
  scrollToTop: (options?: ScrollToOptions) => void;

  /**
   * 滚动到底部
   */
  scrollToBottom: (options?: ScrollToOptions) => void;

  /**
   * 获取项位置
   */
  getItemPosition: (index: number) => ItemPosition | null;

  /**
   * 获取所有项位置
   */
  getAllItemPositions: () => Map<number, ItemPosition>;

  /**
   * 获取列高度
   */
  getColumnHeights: () => number[];

  /**
   * 获取布局信息
   */
  getLayoutInfo: () => LayoutInfo;

  /**
   * 获取视口信息
   */
  getViewportInfo: () => ViewportInfo;

  /**
   * 获取可见项索引
   */
  getVisibleItems: () => Set<number>;

  /**
   * 强制更新
   */
  forceUpdate: () => void;

  /**
   * 获取容器 DOM
   */
  getContainer: () => HTMLDivElement | null;

  /**
   * 获取项 DOM
   */
  getItemElement: (index: number) => HTMLElement | null;

  /**
   * 测量项尺寸
   */
  measureItem: (index: number) => Promise<{ width: number; height: number }>;
}

export interface ScrollToItemOptions {
  behavior?: "auto" | "smooth";
  block?: "start" | "center" | "end" | "nearest";
  inline?: "start" | "center" | "end" | "nearest";
  offset?: number; // 额外偏移
}

export interface ScrollToOptions {
  behavior?: "auto" | "smooth";
  offset?: number;
}

// ============ 核心组件实现 ============

const WaterfallCore = forwardRef<WaterfallCoreRef, WaterfallCoreProps>(
  function WaterfallCore<T = any>(
    props: WaterfallCoreProps<T>,
    ref: React.ForwardedRef<WaterfallCoreRef>
  ) {
    const {
      items = [],
      renderItem,
      keyExtractor = (item, index) => index,
      columns = 3,
      gap = 16,
      rowGap,
      columnGap,
      padding = 0,
      containerStyle,
      containerClassName,
      itemStyle,
      itemClassName,
      virtual = false,
      estimateItemHeight = 300,
      overscan = 2,
      useTransform = true,
      throttleDelay = 16,
      debounceDelay = 150,
      onMount,
      onUnmount,
      onBeforeLayout,
      onLayout,
      onLayoutComplete,
      onItemMount,
      onItemUnmount,
      onItemEnterViewport,
      onItemLeaveViewport,
      onScroll,
      onResize,
      onReachBottom,
      onItemClick,
      children,
      containerRefExternal,
      itemRefsExternal,
      debug = false,
    } = props;

    // ===== Refs =====
    const containerRef = containerRefExternal || useRef<HTMLDivElement>(null);
    const itemRefsMap =
      itemRefsExternal || useRef<Map<number, HTMLElement>>(new Map());
    const resizeObserverRef = useRef<ResizeObserver | null>(null);
    const scrollTimerRef = useRef<number>();
    const layoutTimerRef = useRef<number>();

    // ===== State =====
    const [layoutInfo, setLayoutInfo] = useState<LayoutInfo>({
      columns,
      columnWidth: 0,
      gap: columnGap || gap,
      columnHeights: Array(columns).fill(0),
      totalHeight: 0,
      containerWidth: 0,
      containerHeight: 0,
    });

    const [itemPositions, setItemPositions] = useState<
      Map<number, ItemPosition>
    >(new Map());

    const [viewportInfo, setViewportInfo] = useState<ViewportInfo>({
      scrollTop: 0,
      scrollLeft: 0,
      scrollHeight: 0,
      scrollWidth: 0,
      clientHeight: 0,
      clientWidth: 0,
      isScrolling: false,
      direction: null,
    });

    const [visibleItems, setVisibleItems] = useState<Set<number>>(new Set());
    const [, forceUpdateState] = useState({});

    // ===== 计算内边距 =====
    const paddingValues = useMemo(() => {
      if (typeof padding === "number") {
        return { top: padding, right: padding, bottom: padding, left: padding };
      }
      return {
        top: padding.top || 0,
        right: padding.right || 0,
        bottom: padding.bottom || 0,
        left: padding.left || 0,
      };
    }, [padding]);

    // ===== 计算间距 =====
    const rowGapValue = rowGap !== undefined ? rowGap : gap;
    const columnGapValue = columnGap !== undefined ? columnGap : gap;

    // ===== 布局计算 =====
    const calculateLayout = useCallback(async () => {
      const container = containerRef.current;
      if (!container || items.length === 0) return;

      // 触发 onBeforeLayout 钩子
      if (onBeforeLayout) {
        const shouldContinue = await onBeforeLayout();
        if (!shouldContinue) return;
      }

      if (debug) console.time("[WaterfallCore] Layout calculation");

      const containerWidth = container.clientWidth;
      const contentWidth =
        containerWidth - paddingValues.left - paddingValues.right;
      const columnWidth =
        (contentWidth - columnGapValue * (columns - 1)) / columns;

      const columnHeights = Array(columns).fill(paddingValues.top);
      const newPositions = new Map<number, ItemPosition>();

      // 触发 onLayout 钩子
      if (onLayout) onLayout();

      // 计算每个项的位置
      for (let i = 0; i < items.length; i++) {
        const itemElement = itemRefsMap.current.get(i);
        let itemHeight = estimateItemHeight;

        // 尝试获取实际高度
        if (itemElement) {
          itemHeight = itemElement.offsetHeight || estimateItemHeight;
        }

        // 找到最短的列
        const shortestColumnIndex = columnHeights.indexOf(
          Math.min(...columnHeights)
        );
        const column = shortestColumnIndex;
        const x = paddingValues.left + column * (columnWidth + columnGapValue);
        const y = columnHeights[column];

        newPositions.set(i, {
          x,
          y,
          width: columnWidth,
          height: itemHeight,
          column,
          row: Math.floor(i / columns),
        });

        // 更新列高度
        columnHeights[column] += itemHeight + rowGapValue;
      }

      const totalHeight = Math.max(...columnHeights) + paddingValues.bottom;

      setLayoutInfo({
        columns,
        columnWidth,
        gap: columnGapValue,
        columnHeights,
        totalHeight,
        containerWidth,
        containerHeight: container.clientHeight,
      });

      setItemPositions(newPositions);

      // 触发 onLayoutComplete 钩子
      if (onLayoutComplete) onLayoutComplete();

      if (debug) {
        console.timeEnd("[WaterfallCore] Layout calculation");
        console.log("[WaterfallCore] Layout info:", {
          columns,
          columnWidth,
          totalHeight,
          itemCount: items.length,
        });
      }
    }, [
      items,
      columns,
      columnGapValue,
      rowGapValue,
      paddingValues,
      estimateItemHeight,
      onBeforeLayout,
      onLayout,
      onLayoutComplete,
      debug,
    ]);

    // ===== 节流的布局计算 =====
    const throttledCalculateLayout = useCallback(() => {
      if (layoutTimerRef.current) {
        window.clearTimeout(layoutTimerRef.current);
      }
      layoutTimerRef.current = window.setTimeout(() => {
        calculateLayout();
      }, debounceDelay);
    }, [calculateLayout, debounceDelay]);

    // ===== 更新视口信息 =====
    const updateViewportInfo = useCallback(() => {
      const container = containerRef.current;
      if (!container) return;

      const prevScrollTop = viewportInfo.scrollTop;
      const newScrollTop = container.scrollTop;
      const direction =
        newScrollTop > prevScrollTop
          ? "down"
          : newScrollTop < prevScrollTop
          ? "up"
          : null;

      setViewportInfo({
        scrollTop: newScrollTop,
        scrollLeft: container.scrollLeft,
        scrollHeight: container.scrollHeight,
        scrollWidth: container.scrollWidth,
        clientHeight: container.clientHeight,
        clientWidth: container.clientWidth,
        isScrolling: true,
        direction,
      });
    }, [viewportInfo.scrollTop]);

    // ===== 计算可见项 =====
    const calculateVisibleItems = useCallback(() => {
      const container = containerRef.current;
      if (!container) return;

      const scrollTop = container.scrollTop;
      const clientHeight = container.clientHeight;
      const viewportTop = scrollTop - overscan * estimateItemHeight;
      const viewportBottom =
        scrollTop + clientHeight + overscan * estimateItemHeight;

      const newVisibleItems = new Set<number>();
      const prevVisibleItems = new Set(visibleItems);

      itemPositions.forEach((position, index) => {
        const itemTop = position.y;
        const itemBottom = position.y + position.height;

        if (itemBottom >= viewportTop && itemTop <= viewportBottom) {
          newVisibleItems.add(index);

          // 触发进入视口事件
          if (!prevVisibleItems.has(index) && onItemEnterViewport) {
            onItemEnterViewport(index);
          }
        } else if (prevVisibleItems.has(index) && onItemLeaveViewport) {
          // 触发离开视口事件
          onItemLeaveViewport(index);
        }
      });

      setVisibleItems(newVisibleItems);
    }, [
      itemPositions,
      overscan,
      estimateItemHeight,
      visibleItems,
      onItemEnterViewport,
      onItemLeaveViewport,
    ]);

    // ===== 滚动处理 =====
    const handleScroll = useCallback(() => {
      updateViewportInfo();
      calculateVisibleItems();

      const container = containerRef.current;
      if (!container) return;

      // 触发 onScroll 钩子
      if (onScroll) {
        onScroll(container.scrollTop, container.scrollLeft);
      }

      // 检查是否到达底部
      if (onReachBottom) {
        const scrollTop = container.scrollTop;
        const scrollHeight = container.scrollHeight;
        const clientHeight = container.clientHeight;
        const distanceToBottom = scrollHeight - (scrollTop + clientHeight);

        if (distanceToBottom < 100) {
          onReachBottom(distanceToBottom);
        }
      }

      // 标记滚动结束
      if (scrollTimerRef.current) {
        window.clearTimeout(scrollTimerRef.current);
      }
      scrollTimerRef.current = window.setTimeout(() => {
        setViewportInfo((prev) => ({ ...prev, isScrolling: false }));
      }, 150);
    }, [updateViewportInfo, calculateVisibleItems, onScroll, onReachBottom]);

    // ===== 尺寸变化处理 =====
    const handleResize = useCallback(
      (entries: ResizeObserverEntry[]) => {
        const container = entries[0]?.target as HTMLDivElement;
        if (!container) return;

        const width = container.clientWidth;
        const height = container.clientHeight;

        if (onResize) {
          onResize(width, height);
        }

        throttledCalculateLayout();
      },
      [onResize, throttledCalculateLayout]
    );

    // ===== 挂载时 =====
    useEffect(() => {
      if (onMount) onMount();

      // 初始布局
      calculateLayout();

      // 监听容器尺寸变化
      const container = containerRef.current;
      if (container) {
        resizeObserverRef.current = new ResizeObserver(handleResize);
        resizeObserverRef.current.observe(container);
      }

      return () => {
        if (onUnmount) onUnmount();
        if (resizeObserverRef.current) {
          resizeObserverRef.current.disconnect();
        }
        if (scrollTimerRef.current) {
          window.clearTimeout(scrollTimerRef.current);
        }
        if (layoutTimerRef.current) {
          window.clearTimeout(layoutTimerRef.current);
        }
      };
    }, []);

    // ===== items 变化时重新布局 =====
    useEffect(() => {
      throttledCalculateLayout();
    }, [items, throttledCalculateLayout]);

    // ===== columns 变化时重新布局 =====
    useEffect(() => {
      calculateLayout();
    }, [columns]);

    // ===== 暴露方法 =====
    useImperativeHandle(ref, () => ({
      relayout: calculateLayout,
      scrollToItem: (index, options = {}) => {
        const position = itemPositions.get(index);
        if (!position || !containerRef.current) return;

        const container = containerRef.current;
        const offset = options.offset || 0;
        let scrollTop = position.y + offset;

        if (options.block === "center") {
          scrollTop -= container.clientHeight / 2 - position.height / 2;
        } else if (options.block === "end") {
          scrollTop -= container.clientHeight - position.height;
        }

        container.scrollTo({
          top: Math.max(0, scrollTop),
          behavior: options.behavior || "auto",
        });
      },
      scrollToTop: (options = {}) => {
        containerRef.current?.scrollTo({
          top: options.offset || 0,
          behavior: options.behavior || "auto",
        });
      },
      scrollToBottom: (options = {}) => {
        const container = containerRef.current;
        if (!container) return;
        container.scrollTo({
          top:
            container.scrollHeight -
            container.clientHeight +
            (options.offset || 0),
          behavior: options.behavior || "auto",
        });
      },
      getItemPosition: (index) => itemPositions.get(index) || null,
      getAllItemPositions: () => itemPositions,
      getColumnHeights: () => layoutInfo.columnHeights,
      getLayoutInfo: () => layoutInfo,
      getViewportInfo: () => viewportInfo,
      getVisibleItems: () => visibleItems,
      forceUpdate: () => forceUpdateState({}),
      getContainer: () => containerRef.current,
      getItemElement: (index) => itemRefsMap.current.get(index) || null,
      measureItem: async (index) => {
        const element = itemRefsMap.current.get(index);
        if (!element) {
          return { width: 0, height: 0 };
        }
        return {
          width: element.offsetWidth,
          height: element.offsetHeight,
        };
      },
    }));

    // ===== 渲染项 =====
    const renderItems = () => {
      // 虚拟滚动：只渲染可见项
      const itemsToRender = virtual
        ? Array.from(visibleItems)
        : items.map((_, i) => i);

      return itemsToRender.map((index) => {
        const item = items[index];
        if (!item) return null;

        const position = itemPositions.get(index);
        if (!position) return null;

        const key = keyExtractor(item, index);

        const itemPositionStyle: React.CSSProperties = useTransform
          ? {
              position: "absolute",
              transform: `translate(${position.x}px, ${position.y}px)`,
              width: position.width,
            }
          : {
              position: "absolute",
              left: position.x,
              top: position.y,
              width: position.width,
            };

        return (
          <div
            key={key}
            ref={(el) => {
              if (el) {
                itemRefsMap.current.set(index, el);
                if (onItemMount) onItemMount(index, el);
              } else {
                itemRefsMap.current.delete(index);
                if (onItemUnmount) onItemUnmount(index);
              }
            }}
            style={{
              ...itemPositionStyle,
              ...itemStyle,
            }}
            className={itemClassName}
            onClick={(e) => {
              if (onItemClick) onItemClick(index, item, e);
            }}
            data-index={index}
          >
            {renderItem(item, index)}
          </div>
        );
      });
    };

    // ===== 渲染 =====
    return (
      <div
        ref={containerRef}
        style={{
          position: "relative",
          overflow: "auto",
          ...containerStyle,
        }}
        className={containerClassName}
        onScroll={handleScroll}
      >
        {/* 占位容器（用于撑开滚动高度） */}
        <div
          style={{
            position: "relative",
            width: "100%",
            height: layoutInfo.totalHeight,
          }}
        >
          {renderItems()}
        </div>

        {/* 插件覆盖层 */}
        {children}
      </div>
    );
  }
);

export default WaterfallCore;
```

## 📦 第四步：其他核心文件框架

### `plugins/PluginBus.ts`

```typescript
/**
 * PluginBus - 插件事件总线
 * 与 LazyLoadImagePlugin 的 PluginBus 保持一致
 */
export function createPluginBus() {
  // ... 参考 LazyLoadImagePlugin/plugins/PluginBus.ts 实现
}
```

### `plugins/PluginManager.ts`

```typescript
/**
 * PluginManager - 插件管理器
 * 与 LazyLoadImagePlugin 的 PluginManager 保持一致
 */
export function createPluginManager() {
  // ... 参考 LazyLoadImagePlugin/plugins/PluginManager.ts 实现
}
```

### `plugins/withPlugins.tsx`

```typescript
/**
 * withPlugins - HOC 组合器
 * 与 LazyLoadImagePlugin 的 withPlugins 保持一致
 */
export function withPlugins<T = any>(
  Component: React.ComponentType<WaterfallCoreProps<T>>,
  plugins: WaterfallPlugin<T>[]
) {
  // ... 参考 LazyLoadImagePlugin/plugins/withPlugins.tsx 实现
}
```

### `index.ts` - 主入口

```typescript
// WaterfallPlugin 系统入口
export { default as WaterfallCore } from "./core/WaterfallCore";
export type {
  WaterfallCoreProps,
  WaterfallCoreRef,
  ScrollToOptions,
  ScrollToItemOptions,
} from "./core/WaterfallCore";

// 插件系统
export { withPlugins, createPluginBus, createPluginManager } from "./plugins";
export type {
  WaterfallPlugin,
  WaterfallPluginContext,
  WaterfallPluginHooks,
  PluginManager,
  ItemPosition,
  LayoutInfo,
  ViewportInfo,
  ItemVisibility,
  PerformanceMetrics,
} from "./plugins";

// 自定义插件（按需导出）
export * from "./custom-plugins";
```

这个设计方案：
✅ 与 LazyLoadImagePlugin 架构完全一致
✅ 类型定义完整且考虑了各种场景
✅ 核心组件职责清晰
✅ 扩展性强，易于添加新插件
✅ 性能优化（虚拟滚动、节流、防抖）
✅ 提供完整的生命周期钩子

需要我继续设计具体的插件实现吗？
